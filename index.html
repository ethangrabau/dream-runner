<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bean Bag Dream Runner</title>
    <style>
        body { 
            margin: 0;
            overflow: hidden;
            background: #fff;
        }
        canvas { 
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: black;
            font-family: 'Courier New', monospace;
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="info">DREAM RUNNER<br>Left/Right to move, Up + Left/Right to turn<br>Hold SPACE to fly</div>
    <script>
        class BeanBagRunner {
            constructor() {
                this.velocity = new THREE.Vector3();
                this.rotation = 0;
                this.direction = new THREE.Vector3(0, 0, -1);
                this.isFlying = false;
                this.setup();
                this.createCharacter();
                this.createInfiniteGround();
                this.createTreescape();
                this.setupControls();
                this.animate();
            }

            setup() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xffffff);
                
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 4, 8);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(this.renderer.domElement);

                const ambientLight = new THREE.AmbientLight(0x404040);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(1, 1, 1);
                this.scene.add(ambientLight);
                this.scene.add(directionalLight);

                this.runningSpeed = 0.4;
                this.score = 0;
                this.trees = [];
                this.groundY = 2;
                this.maxFlyHeight = 15;
                this.treeChunks = new Map();
                this.chunkSize = 100;
            }

            createCharacter() {
                this.character = new THREE.Group();
                
                const bodyGeometry = new THREE.BoxGeometry(1, 1.2, 0.8);
                const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x6A5ACD });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.scale.set(1, 1, 0.8);
                this.character.add(body);

                this.leftLeg = this.createSegmentedLeg();
                this.rightLeg = this.createSegmentedLeg();
                this.leftLeg.position.set(-0.3, -0.6, 0);
                this.rightLeg.position.set(0.3, -0.6, 0);
                this.character.add(this.leftLeg);
                this.character.add(this.rightLeg);

                this.character.position.set(0, this.groundY, 0);
                this.character.rotation.y = Math.PI;
                this.scene.add(this.character);
            }

            createSegmentedLeg() {
                const leg = new THREE.Group();
                
                const legMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                
                const upperLegGeometry = new THREE.BoxGeometry(0.15, 0.4, 0.15);
                const upperLeg = new THREE.Mesh(upperLegGeometry, legMaterial);
                upperLeg.position.y = -0.2;
                leg.add(upperLeg);

                const lowerLegGeometry = new THREE.BoxGeometry(0.12, 0.4, 0.12);
                const lowerLeg = new THREE.Mesh(lowerLegGeometry, legMaterial);
                lowerLeg.position.y = -0.6;
                leg.add(lowerLeg);

                return leg;
            }

            createInfiniteGround() {
                const size = 2000;
                const geometry = new THREE.PlaneGeometry(size, size, 100, 100);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0x000000, 
                    wireframe: true,
                    transparent: true,
                    opacity: 0.2
                });
                
                this.ground = new THREE.Mesh(geometry, material);
                this.ground.rotation.x = -Math.PI / 2;
                this.ground.position.y = 0;
                this.scene.add(this.ground);
            }

            getChunkKey(x, z) {
                const chunkX = Math.floor(x / this.chunkSize);
                const chunkZ = Math.floor(z / this.chunkSize);
                return `${chunkX},${chunkZ}`;
            }

            createTreesForChunk(chunkKey) {
                if (this.treeChunks.has(chunkKey)) return;

                const [chunkX, chunkZ] = chunkKey.split(',').map(Number);
                const trees = [];

                for (let i = 0; i < 50; i++) {
                    const x = (chunkX * this.chunkSize) + Math.random() * this.chunkSize;
                    const z = (chunkZ * this.chunkSize) + Math.random() * this.chunkSize;
                    const tree = this.createTree(x, 0, z);
                    trees.push(tree);
                    this.scene.add(tree);
                }

                this.treeChunks.set(chunkKey, trees);
            }

            createTreescape() {
                for (let x = -2; x <= 2; x++) {
                    for (let z = -2; z <= 2; z++) {
                        const chunkKey = `${x},${z}`;
                        this.createTreesForChunk(chunkKey);
                    }
                }
            }

            createTree(x, y, z) {
                const group = new THREE.Group();
                
                const trunkGeometry = new THREE.BoxGeometry(0.1, 1 + Math.random(), 0.1);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.5
                });
                
                const trunk = new THREE.Mesh(trunkGeometry, material);
                trunk.position.y = trunkGeometry.parameters.height / 2;
                group.add(trunk);

                const topHeight = 1 + Math.random() * 0.5;
                const topGeometry = new THREE.ConeGeometry(0.5, topHeight, 4);
                const top = new THREE.Mesh(topGeometry, material);
                top.position.y = trunk.position.y + trunkGeometry.parameters.height/2 + topHeight/2;
                group.add(top);

                group.position.set(x, y, z);
                return group;
            }

            setupControls() {
                this.keys = {};
                window.addEventListener('keydown', (e) => this.keys[e.code] = true);
                window.addEventListener('keyup', (e) => this.keys[e.code] = false);
                window.addEventListener('resize', () => this.handleResize());
            }

            handleResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            update() {
                const rotationSpeed = 0.03;
                const sideSpeed = 0.15;

                if (this.keys['ArrowUp']) {
                    if (this.keys['ArrowLeft']) {
                        this.rotation += rotationSpeed;
                        this.character.rotation.y += rotationSpeed;
                        this.direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotationSpeed);
                    }
                    if (this.keys['ArrowRight']) {
                        this.rotation -= rotationSpeed;
                        this.character.rotation.y -= rotationSpeed;
                        this.direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), -rotationSpeed);
                    }
                } else {
                    if (this.keys['ArrowLeft']) {
                        const moveVec = new THREE.Vector3(-sideSpeed, 0, 0);
                        moveVec.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.rotation);
                        this.character.position.add(moveVec);
                    }
                    if (this.keys['ArrowRight']) {
                        const moveVec = new THREE.Vector3(sideSpeed, 0, 0);
                        moveVec.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.rotation);
                        this.character.position.add(moveVec);
                    }
                }

                const forwardMove = this.direction.clone().multiplyScalar(this.runningSpeed);
                this.character.position.add(forwardMove);

                const gravity = 0.015;
                const flyForce = 0.2;
                const maxFlySpeed = 0.4;

                if (this.keys['Space']) {
                    this.velocity.y = Math.min(this.velocity.y + flyForce, maxFlySpeed);
                    this.isFlying = true;
                } else {
                    this.velocity.y = Math.max(this.velocity.y - gravity, -maxFlySpeed);
                    this.isFlying = false;
                }

                this.character.position.y += this.velocity.y;
                if (this.character.position.y < this.groundY) {
                    this.character.position.y = this.groundY;
                    this.velocity.y = 0;
                } else if (this.character.position.y > this.maxFlyHeight) {
                    this.character.position.y = this.maxFlyHeight;
                    this.velocity.y = 0;
                }

                const runCycle = (Date.now() % 1000) / 1000;
                const legSpeed = this.character.position.y === this.groundY ? 1.5 : 0.3;
                const legAngle = Math.sin(runCycle * Math.PI * 2) * 0.8 * legSpeed;
                
                this.leftLeg.rotation.x = legAngle;
                this.rightLeg.rotation.x = -legAngle;

                const currentChunk = this.getChunkKey(this.character.position.x, this.character.position.z);
                const [currentX, currentZ] = currentChunk.split(',').map(Number);

                for (let x = currentX - 2; x <= currentX + 2; x++) {
                    for (let z = currentZ - 2; z <= currentZ + 2; z++) {
                        const chunkKey = `${x},${z}`;
                        this.createTreesForChunk(chunkKey);
                    }
                }

                for (const [chunkKey, trees] of this.treeChunks.entries()) {
                    const [x, z] = chunkKey.split(',').map(Number);
                    if (Math.abs(x - currentX) > 3 || Math.abs(z - currentZ) > 3) {
                        trees.forEach(tree => this.scene.remove(tree));
                        this.treeChunks.delete(chunkKey);
                    }
                }

                this.ground.position.x = Math.floor(this.character.position.x / 100) * 100;
                this.ground.position.z = Math.floor(this.character.position.z / 100) * 100;

                const cameraHeight = this.character.position.y + 3;
                const cameraDistance = 8 + (this.character.position.y - this.groundY) * 0.5;
                
                const cameraOffset = new THREE.Vector3(0, 0, cameraDistance);
                cameraOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.rotation);
                
                this.camera.position.x = this.character.position.x + cameraOffset.x;
                this.camera.position.y = cameraHeight;
                this.camera.position.z = this.character.position.z + cameraOffset.z;
                this.camera.lookAt(
                    this.character.position.x,
                    this.character.position.y + 1,
                    this.character.position.z
                );

                this.score = Math.floor(
                    Math.sqrt(
                        Math.pow(this.character.position.x, 2) + 
                        Math.pow(this.character.position.z, 2)
                    )
                );
                
                document.getElementById('info').innerHTML = 
                    `DREAM RUNNER<br>Left/Right to move, Up + Left/Right to turn<br>Hold SPACE to fly<br>Score: ${this.score}`;
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.update();
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Start the game when the page loads
        window.addEventListener('load', () => {
            new BeanBagRunner();
        });
    </script>
</body>
</html>